{
  "Id": 50332187,
  "Comment": "",
  "IsScript": true,
  "RunOnMapInit": false,
  "Script": "///////////////////////////////////////////////////////////////\r\n/// The Map Meta Data Library\r\n/// Version: v1.00       \r\n/// Last Modified: April 24, 2009\r\n/// Author Chain: Strilanc, [insert next ...]\r\n///////////////////////////////////////////////////////////////\r\n/// This library is used to emit standardized meta data which parsers and bot hosts can use to record relevant\r\n/// game statistics like \"hero kills\" which would otherwise be impossible to record automatically.\r\n///\r\n/// In particular, the flag function can be used to indicate if a leaver should be awarded a win or not. Replays\r\n/// don't contain enough information to easily tell winners who leave from losers who leave. (for example: people\r\n/// who leave while end-game stats are being shown)\r\n///////////////////////////////////////////////////////////////\r\n/// Interface:\r\n///   void FlagPlayer(player, flag_constant)\r\n///   void DefineValue(name, type_constant, goal_constant, suggest_constant)\r\n///   void UpdateValueInt(name, player, operation_constant, value)\r\n///   void UpdateValueReal(name, player, operation_constant, value)\r\n///   void UpdateValueString(name, player, value)\r\n///   void DefineEvent0(name, format) /////////////////////////\r\nlibrary MMD initializer init\r\n    globals\r\n        public constant integer GOAL_NONE = 101\r\n        public constant integer GOAL_HIGH = 102\r\n        public constant integer GOAL_LOW = 103\r\n        \r\n        public constant integer TYPE_STRING = 101\r\n        public constant integer TYPE_REAL = 102\r\n        public constant integer TYPE_INT = 103\r\n\r\n        public constant integer OP_ADD = 101\r\n        public constant integer OP_SUB = 102\r\n        public constant integer OP_SET = 103\r\n\r\n        public constant integer SUGGEST_NONE = 101\r\n        public constant integer SUGGEST_TRACK = 102\r\n        public constant integer SUGGEST_LEADERBOARD = 103\r\n\r\n        public constant integer FLAG_DRAWER = 101\r\n        public constant integer FLAG_LOSER = 102\r\n        public constant integer FLAG_WINNER = 103\r\n        public constant integer FLAG_LEAVER = 104\r\n        public constant integer FLAG_PRACTICING = 105\r\n    endglobals\r\n\r\n    ///////////////////////////////////////////////////////////////\r\n    /// Private variables and constants\r\n    ///////////////////////////////////////////////////////////////\r\n    globals\r\n        private constant boolean SHOW_DEBUG_MESSAGES = true\r\n        \r\n        private constant string chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_-+= \\\\!@#$%^&*()/?>.<,;:'\\\"{}[]|`~\"\r\n        private constant integer num_chars = StringLength(chars)\r\n        private string array flags\r\n        private string array goals\r\n        private string array ops\r\n        private string array types\r\n        private string array suggestions\r\n        private boolean initialized = false\r\n                \r\n        private gamecache gc = null\r\n        private constant string ESCAPED_CHARS = \" \\\\\"\r\n        \r\n        private constant integer CURRENT_VERSION = 1\r\n        private constant integer MINIMUM_PARSER_VERSION = 1\r\n        private constant string FILENAME = \"MMD.Dat\"\r\n        private constant string M_KEY_VAL = \"val:\"\r\n        private constant string M_KEY_CHK = \"chk:\"\r\n        private constant integer NUM_SENDERS_NAIVE = 1\r\n        private constant integer NUM_SENDERS_SAFE = 3\r\n        private integer num_senders = NUM_SENDERS_NAIVE\r\n        private integer num_msg = 0        \r\n        \r\n        private timer clock = CreateTimer()\r\n        private string array q_msg\r\n        private real array q_time\r\n        private integer array q_index\r\n        private keyword QueueNode\r\n        private QueueNode q_head = 0\r\n        private QueueNode q_tail = 0\r\n    endglobals\r\n    \r\n    ///////////////////////////////////////////////////////////////\r\n    /// Private functions\r\n    ///////////////////////////////////////////////////////////////\r\n    \r\n    ///Triggered when tampering is detected. Increases the number of safeguards against tampering.\r\n    public function RaiseGuard takes string reason returns nothing\r\n        debug if SHOW_DEBUG_MESSAGES then\r\n        debug     call BJDebugMsg(\"MMD: Guard Raised! (\" + reason + \")\")\r\n        debug endif\r\n        set num_senders = NUM_SENDERS_SAFE //increase number of players voting on each message\r\n    endfunction\r\n\r\n    ///Returns seconds elapsed in game time\r\n    private function time takes nothing returns real\r\n        return TimerGetElapsed(clock)\r\n    endfunction\r\n    \r\n    ///Initializes the char-to-int conversion\r\n    private function prepC2I takes nothing returns nothing\r\n        local integer i = 0\r\n        local string id\r\n        loop\r\n            exitwhen i >= num_chars\r\n            set id = SubString(chars, i, i+1)\r\n            if id == StringCase(id, true) then\r\n                set id = id + \"U\"\r\n            endif\r\n            call StoreInteger(gc, \"c2i\", id, i)\r\n            set i = i + 1\r\n        endloop\r\n    endfunction\r\n    ///Converts a character to an integer\r\n    private function C2I takes string c returns integer\r\n        local integer i\r\n        local string id = c\r\n        if id == StringCase(id, true) then\r\n            set id = id + \"U\"\r\n        endif\r\n        set i = GetStoredInteger(gc, \"c2i\", id)\r\n        if (i < 0 or i >= num_chars or SubString(chars, i, i+1) != c) and HaveStoredInteger(gc, \"c2i\", id) then\r\n            //A cheater sent a fake sync to screw with the cached values\r\n            set i = 0\r\n            loop\r\n                exitwhen i >= num_chars //just a weird character\r\n                if c == SubString(chars, i, i+1) then //cheating!\r\n                    call RaiseGuard(\"c2i poisoned\")\r\n                    call StoreInteger(gc, \"c2i\", id, i)\r\n                    exitwhen true\r\n                endif\r\n                set i = i + 1\r\n            endloop\r\n        endif\r\n        return i\r\n    endfunction\r\n\r\n    ///Computes a weak hash value, hopefully secure enough for our purposes\r\n    private function poor_hash takes string s, integer seed returns integer\r\n        local integer n = StringLength(s)\r\n        local integer m = n + seed\r\n        local integer i = 0\r\n        loop\r\n            exitwhen i >= n\r\n            set m = m * 41 + C2I(SubString(s, i, i+1))\r\n            set i = i + 1\r\n        endloop\r\n        return m\r\n    endfunction\r\n\r\n    ///Stores previously sent messages for tamper detection purposes\r\n    private struct QueueNode\r\n        readonly real timeout\r\n        readonly string msg\r\n        readonly integer checksum\r\n        readonly string key\r\n        public QueueNode next = 0\r\n        public static method create takes integer id, string msg returns QueueNode\r\n            local QueueNode this = QueueNode.allocate()\r\n            set .timeout = time() + 7.0 + GetRandomReal(0, 2+0.1*GetPlayerId(GetLocalPlayer()))\r\n            set .msg = msg\r\n            set .checksum = poor_hash(.msg, id)\r\n            set .key = I2S(id)\r\n            return this\r\n        endmethod\r\n        private method onDestroy takes nothing returns nothing\r\n            call FlushStoredInteger(gc, M_KEY_VAL+.key, .msg)\r\n            call FlushStoredInteger(gc, M_KEY_CHK+.key, .key)\r\n            set .msg = null\r\n            set .key = null\r\n            set .next = 0\r\n        endmethod\r\n        public method send takes nothing returns nothing\r\n            call StoreInteger(gc, M_KEY_VAL+.key, .msg, .checksum)\r\n            call StoreInteger(gc, M_KEY_CHK+.key, .key, .checksum)\r\n            call SyncStoredInteger(gc, M_KEY_VAL+.key, .msg)\r\n            call SyncStoredInteger(gc, M_KEY_CHK+.key, .key)\r\n        endmethod\r\n    endstruct\r\n    \r\n    ///Returns true for a fixed size uniform random subset of players in the game\r\n    private function isEmitter takes nothing returns boolean\r\n        local integer i = 0\r\n        local integer n = 0\r\n        local integer r\r\n        local integer array picks\r\n        local boolean array pick_flags\r\n        loop\r\n            exitwhen i >= 24\r\n            if GetPlayerController(Player(i)) == MAP_CONTROL_USER and GetPlayerSlotState(Player(i)) == PLAYER_SLOT_STATE_PLAYING then\r\n                if n < num_senders then //initializing picks\r\n                    set picks[n] = i\r\n                    set pick_flags[i] = true\r\n                else //maintain the invariant 'P(being picked) = c/n'\r\n                    set r = GetRandomInt(0, n)\r\n                    if r < num_senders then\r\n                        set pick_flags[picks[r]] = false\r\n                        set picks[r] = i\r\n                        set pick_flags[i] = true\r\n                    endif\r\n                endif\r\n                set n = n + 1\r\n            endif\r\n            set i = i + 1\r\n        endloop\r\n        return pick_flags[GetPlayerId(GetLocalPlayer())]\r\n    endfunction\r\n    \r\n    ///Places meta-data in the replay and in network traffic\r\n    private function emit takes string message returns nothing\r\n        local QueueNode q\r\n        if not initialized then\r\n            call BJDebugMsg(\"MMD Emit Error: Library not initialized yet.\")\r\n            return\r\n        endif\r\n        \r\n        //remember sent messages for tamper check\r\n        set q = QueueNode.create(num_msg, message)\r\n        if q_head == 0 then\r\n            set q_head = q\r\n        else\r\n            set q_tail.next = q\r\n        endif\r\n        set q_tail = q\r\n                \r\n        //send new message\r\n        set num_msg = num_msg + 1\r\n        if isEmitter() then\r\n            call q.send()\r\n        endif\r\n    endfunction\r\n\r\n    ///Performs tamper checks\r\n    private function tick takes nothing returns nothing\r\n        local QueueNode q\r\n        local integer i\r\n        \r\n        //check previously sent messages for tampering\r\n        set q = q_head\r\n        loop\r\n            exitwhen q == 0 or q.timeout >= time()\r\n            if not HaveStoredInteger(gc, M_KEY_VAL+q.key, q.msg) then\r\n                call RaiseGuard(\"message skipping\")\r\n                call q.send()\r\n            elseif not HaveStoredInteger(gc, M_KEY_CHK+q.key, q.key) then\r\n                call RaiseGuard(\"checksum skipping\")\r\n                call q.send()\r\n            elseif GetStoredInteger(gc, M_KEY_VAL+q.key, q.msg) != q.checksum then\r\n                call RaiseGuard(\"message tampering\")\r\n                call q.send()\r\n            elseif GetStoredInteger(gc, M_KEY_CHK+q.key, q.key) != q.checksum then\r\n                call RaiseGuard(\"checksum tampering\")\r\n                call q.send()\r\n            endif\r\n            set q_head = q.next\r\n            call q.destroy()\r\n            set q = q_head\r\n        endloop\r\n        if q_head == 0 then\r\n            set q_tail = 0\r\n        endif\r\n        \r\n        //check for future message tampering\r\n        set i = 0\r\n        loop\r\n            exitwhen not HaveStoredInteger(gc, M_KEY_CHK+I2S(num_msg), I2S(num_msg))\r\n            call RaiseGuard(\"message insertion\")\r\n            call emit(\"Blank\")\r\n            set i = i + 1\r\n            exitwhen i >= 10\r\n        endloop\r\n    endfunction\r\n    \r\n    ///Replaces control characters with escape sequences\r\n    private function pack takes string value returns string\r\n        local integer j\r\n        local integer i = 0\r\n        local string result = \"\"\r\n        local string c\r\n        loop //for each character in argument string\r\n            exitwhen i >= StringLength(value)\r\n            set c = SubString(value, i, i+1)\r\n            set j = 0\r\n            loop //for each character in escaped chars string\r\n                exitwhen j >= StringLength(ESCAPED_CHARS)\r\n                //escape control characters\r\n                if c == SubString(ESCAPED_CHARS, j, j+1) then\r\n                    set c = \"\\\\\" + c\r\n                    exitwhen true\r\n                endif\r\n                set j = j + 1\r\n            endloop\r\n            set result = result + c\r\n            set i = i + 1\r\n        endloop\r\n        return result\r\n    endfunction\r\n    \r\n    ///Updates the value of a defined variable for a given player\r\n    private function update_value takes string name, player p, string op, string value, integer val_type returns nothing\r\n        local integer id = GetPlayerId(p)\r\n        if p == null or id < 0 or id >= 24 then\r\n            //call BJDebugMsg(\"MMD Set Error: Invalid player. Must be P1 to P24.\")\r\n        elseif val_type != GetStoredInteger(gc, \"types\", name) then\r\n            call BJDebugMsg(\"MMD Set Error: Updated value of undefined variable or used value of incorrect type. Value type: \" + I2S(val_type) + \". Value: \" + value + \". Name: \" + name + \". Operation: \" + op)\r\n        elseif StringLength(op) == 0 then\r\n            call BJDebugMsg(\"MMD Set Error: Unrecognized operation type.\")        \r\n        elseif StringLength(name) > 50 then\r\n            call BJDebugMsg(\"MMD Set Error: Variable name is too long.\")\r\n        elseif StringLength(name) == 0 then\r\n            call BJDebugMsg(\"MMD Set Error: Variable name is empty.\")\r\n        else\r\n            //call BJDebugMsg (\"MMD Update: [name: \" + name + \"] [pid: \" + I2S (GetPlayerId (p)) + \"] [op: \" + op + \"] [value: \" + value + \"] [val_type: \" + I2S (val_type) + \"]\")\r\n            call emit(\"VarP \" + I2S(id) + \" \" + pack(name) + \" \" + op + \" \" + value)\r\n        endif\r\n    endfunction\r\n\r\n    ///Defines an event's arguments and format\r\n    private function DefineEvent takes string name, integer num_args, string format, string arg_data returns nothing\r\n        if GetStoredInteger(gc, \"events\", name) != 0 then\r\n            call BJDebugMsg(\"MMD DefEvent Error: Event redefined.\")\r\n        else\r\n            call StoreInteger(gc, \"events\", name, num_args+1)\r\n            call emit(\"DefEvent \" + pack(name) + \" \" + I2S(num_args) + \" \" + arg_data + pack(format))\r\n        endif\r\n    endfunction\r\n    \r\n    ///Places an event in the meta-data\r\n    private function LogEvent takes string name, integer num_args, string data returns nothing\r\n        if GetStoredInteger(gc, \"events\", name) != num_args+1 then\r\n            call BJDebugMsg(\"MMD LogEvent Error: Event not defined or defined with different # of args.\")\r\n        else\r\n            call emit(\"Event \" + pack(name) + data)\r\n        endif\r\n    endfunction\r\n\r\n    ///////////////////////////////////////////////////////////////\r\n    /// Public functions\r\n    ///////////////////////////////////////////////////////////////\r\n\r\n    ///Sets a player flag like \"win_on_leave\"\r\n    public function FlagPlayer takes player p, integer flag_type returns nothing\r\n        local string flag = flags[flag_type]\r\n        local integer id = GetPlayerId(p)\r\n        if p == null or id < 0 or id >= 24 then\r\n            call BJDebugMsg(\"MMD Flag Error: Invalid player. Must be P1 to P24.\")\r\n        elseif StringLength(flag) == 0 then\r\n            call BJDebugMsg(\"MMD Flag Error: Unrecognized flag type.\")\r\n        elseif GetPlayerController(Player(id)) == MAP_CONTROL_USER then\r\n            call emit(\"FlagP \" + I2S(id) + \" \" + flag)\r\n        endif\r\n    endfunction\r\n\r\n    ///Defines a variable to store things in\r\n    public function DefineValue takes string name, integer value_type, integer goal_type, integer suggestion_type returns nothing\r\n        local string goal = goals[goal_type]\r\n        local string vtype = types[value_type]\r\n        local string stype = suggestions[suggestion_type]\r\n        if goal == null then\r\n            call BJDebugMsg(\"MMD Def Error: Unrecognized goal type.\")\r\n        elseif vtype == null then\r\n            call BJDebugMsg(\"MMD Def Error: Unrecognized value type.\")\r\n        elseif stype == null then\r\n            call BJDebugMsg(\"Stats Def Error: Unrecognized suggestion type.\")\r\n        elseif StringLength(name) > 32 then\r\n            call BJDebugMsg(\"MMD Def Error: Variable name is too long.\")\r\n        elseif StringLength(name) == 0 then\r\n            call BJDebugMsg(\"MMD Def Error: Variable name is empty.\")\r\n        elseif value_type == TYPE_STRING and goal_type != GOAL_NONE then\r\n            call BJDebugMsg(\"MMD Def Error: Strings must have goal type of none.\")\r\n        elseif GetStoredInteger(gc, \"types\", name) != 0 then\r\n            call BJDebugMsg(\"MMD Def Error: Value redefined.\")\r\n        else\r\n            call StoreInteger(gc, \"types\", name, value_type)\r\n            call emit(\"DefVarP \" + pack(name) + \" \" + vtype + \" \" + goal + \" \" + stype)\r\n        endif\r\n    endfunction\r\n\r\n    ///Updates the value of an integer variable\r\n    public function UpdateValueInt takes string name, player p, integer op, integer value returns nothing\r\n        call update_value(name, p, ops[op], I2S(value), TYPE_INT)\r\n    endfunction\r\n    \r\n    ///Updates the value of a real variable\r\n    public function UpdateValueReal takes string name, player p, integer op, real value returns nothing\r\n        call update_value(name, p, ops[op], R2S(value), TYPE_REAL)\r\n    endfunction\r\n    \r\n    ///Updates the value of a string variable\r\n    public function UpdateValueString takes string name, player p, string value returns nothing\r\n        local string q = \"\\\"\"\r\n        call update_value(name, p, ops[OP_SET], q + pack(value) + q, TYPE_STRING)\r\n    endfunction    \r\n    \r\n    public function DefineEvent0 takes string name, string format returns nothing\r\n        call DefineEvent(name, 0, format, \"\")\r\n    endfunction\r\n    public function DefineEvent1 takes string name, string format, string argName0 returns nothing\r\n        call DefineEvent(name, 1, format, pack(argName0) + \" \")\r\n    endfunction\r\n    public function DefineEvent2 takes string name, string format, string argName0, string argName1 returns nothing\r\n        call DefineEvent(name, 2, format, pack(argName0) + \" \" + pack(argName1) + \" \")\r\n    endfunction\r\n    public function DefineEvent3 takes string name, string format, string argName0, string argName1, string argName2 returns nothing\r\n        call DefineEvent(name, 3, format, pack(argName0) + \" \" + pack(argName1) + \" \" + pack(argName2) + \" \")\r\n    endfunction\r\n    \r\n    public function LogEvent0 takes string name returns nothing\r\n        call LogEvent(name, 0, \"\")\r\n    endfunction\r\n    public function LogEvent1 takes string name, string arg0 returns nothing\r\n        call LogEvent(name, 1, \" \" + pack(arg0))\r\n    endfunction\r\n    public function LogEvent2 takes string name, string arg0, string arg1 returns nothing\r\n        call LogEvent(name, 2, \" \" + pack(arg0) + \" \" + pack(arg1))\r\n    endfunction\r\n    public function LogEvent3 takes string name, string arg0, string arg1, string arg2 returns nothing\r\n        call LogEvent(name, 3, \" \" + pack(arg0) + \" \" + pack(arg1) + \" \" + pack(arg2))\r\n    endfunction\r\n\r\n    ///Emits meta-data which parsers will ignore unless they are customized to understand it\r\n    public function LogCustom takes string unique_identifier, string data returns nothing\r\n        call emit(\"custom \" + pack(unique_identifier) + \" \" + pack(data))\r\n    endfunction\r\n\r\n    ///////////////////////////////////////////////////////////////\r\n    /// Initialization\r\n    ///////////////////////////////////////////////////////////////\r\n    \r\n    ///Emits initialization data\r\n    private function init2 takes nothing returns nothing\r\n        local integer i\r\n        local trigger t\r\n        set initialized = true\r\n        \r\n        call emit(\"init version \" + I2S(MINIMUM_PARSER_VERSION) + \" \" + I2S(CURRENT_VERSION))\r\n\r\n        set i = 0\r\n        loop\r\n            exitwhen i >= 24\r\n            if GetPlayerController(Player(i)) == MAP_CONTROL_USER and GetPlayerSlotState(Player(i)) == PLAYER_SLOT_STATE_PLAYING then\r\n                call emit(\"init pid \" + I2S(i) + \" \" + pack(GetPlayerName(Player(i))))\r\n            endif\r\n            set i = i + 1\r\n        endloop\r\n        \r\n        set t = CreateTrigger()\r\n        call TriggerAddAction(t, function tick)\r\n        call TriggerRegisterTimerEvent(t, 0.37, true)\r\n    endfunction\r\n    \r\n    ///Places init2 on a timer, initializes game cache, and translates constants\r\n    private function init takes nothing returns nothing\r\n        local trigger t = CreateTrigger()\r\n        call TriggerRegisterTimerEvent(t, 0, false)\r\n        call TriggerAddAction(t, function init2)\r\n        \r\n        set goals[GOAL_NONE] = \"none\"\r\n        set goals[GOAL_HIGH] = \"high\"\r\n        set goals[GOAL_LOW] = \"low\"\r\n        \r\n        set types[TYPE_INT] = \"int\"\r\n        set types[TYPE_REAL] = \"real\"\r\n        set types[TYPE_STRING] = \"string\"\r\n\r\n        set suggestions[SUGGEST_NONE] = \"none\"\r\n        set suggestions[SUGGEST_TRACK] = \"track\"\r\n        set suggestions[SUGGEST_LEADERBOARD] = \"leaderboard\"\r\n\r\n        set ops[OP_ADD] = \"+=\"\r\n        set ops[OP_SUB] = \"-=\"\r\n        set ops[OP_SET] = \"=\"\r\n\r\n        set flags[FLAG_DRAWER] = \"drawer\"\r\n        set flags[FLAG_LOSER] = \"loser\"\r\n        set flags[FLAG_WINNER] = \"winner\"\r\n        set flags[FLAG_LEAVER] = \"leaver\"\r\n        set flags[FLAG_PRACTICING] = \"practicing\"\r\n\r\n        call FlushGameCache(InitGameCache(FILENAME))\r\n        set gc = InitGameCache(FILENAME)\r\n        call TimerStart(clock, 999999999, false, null)\r\n        call prepC2I()\r\n    endfunction\r\nendlibrary",
  "Events": [],
  "LocalVariables": [],
  "Conditions": [],
  "Actions": []
}